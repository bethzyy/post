# 架构决策记录 (Architecture Decision Records)

本文档记录多模型AI趋势分析项目的关键架构决策及其原因，确保后续修改不会偏离核心设计。

## 决策1: 每个模型自己进行网络搜索

### 决策内容
程序调用模型API时，让模型自己使用其网络搜索能力，而不是由程序搜索后传递给模型。

### 原因
1. **真实性**: 测试的是模型本身的网络搜索和趋势分析能力
2. **完整性**: 模型可以根据需要多次搜索，而不是仅依赖程序提供的一次性搜索结果
3. **对比性**: 不同模型的搜索策略不同，这样可以公平对比

### 错误做法示例
```python
# ❌ 错误：程序搜索后传给模型
search_results = search_with_antigravity(queries)
prompt = f"基于以下搜索结果分析：{search_results}"
model_result = call_model(prompt)
```

### 正确做法示例
```python
# ✅ 正确：让模型自己搜索
prompt = "请使用你的网络搜索能力，搜索并分析2026年AI趋势..."
model_result = call_model(prompt)
```

### 如何验证
检查prompt中是否包含"使用你的网络搜索能力"这样的指令，而不是"这是搜索结果"。

---

## 决策2: Claude/ChatGPT/Gemini必须通过anti-gravity

### 决策内容
Claude、ChatGPT、Gemini等模型必须通过anti-gravity代理调用，anti-gravity提供网络搜索能力。

### 原因
1. **统一接口**: anti-gravity提供统一的OpenAI兼容API
2. **网络搜索**: anti-gravity为这些模型添加了网络搜索能力
3. **本地控制**: 可以通过一个代理管理多个模型的配额和调用

### 配置方式
```python
MODELS_CONFIG = {
    "Claude (Anthropic)": {
        "client_func": get_antigravity_client,  # 使用anti-gravity客户端
        "model_name": "claude-sonnet-4-5-20250514",
        "use_antigravity": True  # 标记为anti-gravity调用
    }
}
```

### 调用方式
```python
if model_config.get('use_antigravity', False):
    response = client.chat.completions.create(
        model=model_config['model_name'],
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4000
    )
```

### 如何验证
- 模型配置中 `client_func` 必须是 `get_antigravity_client`
- `use_antigravity` 标志必须为 `True`
- 调用时使用 `client.chat.completions.create()` (OpenAI兼容接口)

---

## 决策3: 遇到429错误必须等待重试，不允许降级

### 决策内容
当遇到anti-gravity返回429错误（配额已用尽）时，程序必须等待配额恢复后重试，不允许使用替代方案或降低要求。

### 原因
1. **严格要求**: 用户明确要求"不许降低要求"
2. **测试真实性**: 使用替代方案（如训练数据）无法测试模型的实时搜索能力
3. **结果可靠性**: 只有实时搜索才能找到最新的趋势（如ClawdBot）

### 实现方式
```python
if "429" in error_str or "QUOTA_EXHAUSTED" in error_str:
    # 解析等待时间
    wait_match = re.search(r'quotaResetDelay["\s:]+(\d+)s', error_str)
    if wait_match:
        wait_seconds = int(wait_match.group(1))
    else:
        wait_seconds = 300  # 默认5分钟

    retry_count += 1
    if retry_count < max_retries:
        print(f"[429错误] 等待 {wait_seconds/60:.1f} 分钟后重试...")
        time.sleep(wait_seconds)
        continue  # 重试
    else:
        return None  # 达到最大重试次数才放弃
```

### 错误做法示例
```python
# ❌ 错误：直接跳过或使用替代方案
if "429" in error_str:
    return None  # 直接放弃
    # 或者
    return use_cached_data()  # 使用替代方案
```

### 如何验证
检查异常处理代码中是否有 `time.sleep()` 和重试逻辑。

---

## 决策4: 使用通用发现模式，不硬编码产品名

### 决策内容
搜索查询使用通用模式（如"Hacker News front page 2026"），不直接搜索具体产品名（如"ClawdBot"）。

### 原因
1. **真实性**: 模拟真实的研究过程，不会提前知道答案
2. **公平性**: 给予所有产品平等的机会，不会因为搜索词而偏向特定产品
3. **验证性**: 如果模型能通过通用查询找到ClawdBot，证明搜索策略有效

### 通用查询示例
```python
GENERAL_SEARCH_QUERIES = [
    "Hacker News front page 2026",
    "GitHub Trending AI repositories",
    "most popular AI tools developers",
    "Product Hunt popular AI tools",
    "emerging AI frameworks 2026"
]
```

### 错误做法示例
```python
# ❌ 错误：直接搜索产品名
queries = [
    "ClawdBot AI assistant",
    "MoltBot GitHub",
    "ClawdBot reviews"
]
```

### 验证点
- **主要目标**: 分析2026年AI领域Top 5热点
- **验证指标**: 检查是否找到了ClawdBot/MoltBot
- **意义**: 如果找到，说明ClawdBot确实在开发者社区很热门

---

## 决策5: GLM-4.6使用预先收集的数据

### 决策内容
GLM-4.6不进行网络搜索，而是使用预先收集的实时数据（`COLLECTED_REALTIME_DATA`）。

### 原因
1. **技术限制**: GLM-4.6通过ZhipuAI Anthropic兼容接口调用，不支持anti-gravity的网络搜索
2. **MCP工具**: 智谱GLM的MCP工具支持网络搜索，但本项目使用的是Anthropic兼容接口
3. **数据一致性**: 使用统一的预先收集数据，保证GLM-4.6也有实时信息

### 实现方式
```python
if "GLM" in model_name:
    prompt = f"""
## 实时搜索数据
以下是2026年1月通过多源信息收集的数据：
```json
{json.dumps(COLLECTED_REALTIME_DATA, ensure_ascii=False, indent=2)}
```

请基于以上数据分析Top 5热点。
"""
```

### 数据源
```python
COLLECTED_REALTIME_DATA = {
    "sources": [
        "Hacker News - 多个热门AI讨论",
        "GitHub Trending - MoltBot (原ClawdBot) 64,000 stars",
        "Product Hunt - AI工具榜单",
        "Reddit - r/MachineLearning热门讨论",
        # ... 共12个信息源
    ],
    "key_findings": [
        "MoltBot/ClawdBot - 开源个人AI助手",
        "Agentic AI - 多智能体系统趋势",
        # ... 等9个关键发现
    ]
}
```

### 如何验证
- GLM-4.6的prompt必须包含完整的 `COLLECTED_REALTIME_DATA` JSON
- 其他模型的prompt必须包含"使用你的网络搜索能力"

---

## 决策6: 使用ClawdBot/MoltBot作为验证点

### 决策内容
在输出中专门检查是否找到了ClawdBot/MoltBot，并显示其排名和分析。

### 原因
1. **验证搜索质量**: ClawdBot是2026年1月的热门项目（GitHub 64,000 stars）
2. **测试覆盖率**: 验证模型是否覆盖了开发者社区的热点
3. **对比基准**: 不同模型对同一项目的分析可以作为对比基准

### 实现方式
```python
# Prompt中包含验证指令
prompt += """
## 特别验证点
请检查你的搜索结果中是否包含：
- **MoltBot/ClawdBot**（开源个人AI助手）
"""

# 输出中包含验证结果
result = {
    "clawdbot_found": True/False,
    "clawdbot_analysis": "关于MoltBot/ClawdBot的分析"
}
```

### HTML报告展示
```html
<div class="clawdbot-status">
    <h3>✅ ClawdBot已找到</h3>
    <p>MoltBot在中文优化模型领域的意义...</p>
</div>
```

### 如何验证
检查输出JSON中是否包含 `clawdbot_found` 和 `clawdbot_analysis` 字段。

---

## 决策7: 模型名称必须通过测试脚本验证

### 决策内容
新增模型时，必须先运行 `test_antigravity_models.py` 验证模型名称在anti-gravity上是否可用。

### 原因
1. **避免404错误**: anti-gravity上不是所有官方模型名都可用
2. **实际案例**: `gemini-2.0-flash-exp` 返回404，但 `gemini-2.5-pro` 可用
3. **配额状态**: 测试可以显示模型是否配额已用尽

### 测试脚本
```python
# test_antigravity_models.py
test_models = [
    "gemini-2.0-flash-exp",  # 返回404 - 不可用
    "gemini-2.5-pro",         # 返回429 - 可用但配额已尽
    "gpt-4-turbo",            # 返回429 - 可用但配额已尽
]

for model in test_models:
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": "你好"}],
            max_tokens=10
        )
        print(f"[OK] {model} - 可用")
    except Exception as e:
        if "404" in str(e):
            print(f"[X] {model} - 不可用 (404)")
        elif "429" in str(e):
            print(f"[!] {model} - 可用但配额已用尽 (429)")
```

### 添加新模型的流程
1. 运行 `python test_antigravity_models.py`
2. 查看输出，确认模型名称是否返回404或429
3. 如果是429，说明模型可用但配额已尽，可以添加到主程序
4. 如果是404，说明模型名称不正确，需要更换

---

## 架构原则总结

1. **真实性优先**: 测试模型的真实能力，不提供捷径
2. **严格要求**: 不因为配额或其他问题降低测试标准
3. **公平对比**: 所有模型使用相同的测试方法
4. **可验证性**: 通过ClawdBot等验证点确保搜索质量
5. **可扩展性**: 新增模型时遵循验证流程

---

**最后更新**: 2026-01-28 16:00 (UTC+8)
**用途**: 在修改程序前参考此文档，确保不偏离核心架构
